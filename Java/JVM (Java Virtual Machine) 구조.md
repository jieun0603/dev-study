# JVM (Java Virtual Machine)
- **자바 가상 머신**
- JVM 은 기본 운영 체제 및 기계 하드웨어 아키텍처에 의존하지 않는 기계 인터페이스를 제공하기 때문에 가상 이라고 한다.
+ bytecode를 interpreter 형태로 OS에 맞추어 번역, 실행
+ **JAVA와 OS 사이에서 중계자 역할**로
  JAVA가 OS 종류에 구애받지 않고 사용 가능하게 해준다.
+ 일반 어플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데   
  Java 어플리케이션은 JVM을 한 번 더 거치기 때문에 하드웨어에 맞게 완전히 컴파일된 상태가 아니고     
  실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 가지고 있다.
+ 프로그램이 실행되면, JVM은 OS으로부터 이 프로그램이 필요로 하는 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리

+ JVM은 크게 3부분으로 나눌 수 있는데    
  클래스 파일을 로딩한 뒤 검증하고 초기화하는 Class loader,    
  클래스 파일을 저장하는 Runtime DataArea,   
  클래스 파일(바이트코드)를 플랫폼에 맞는 기계어로 변환시켜 실행하는 Execution engine 으로 구성
  ```
  Runtime DataArea 는 다시 method area, heap, java stacks, pc registers, native method stacks의 5가지 영역으로 나뉜다.
  ```

<br>

<img src="https://user-images.githubusercontent.com/73928346/124979372-edc37980-e06d-11eb-9f48-2985824e322c.png" width="500">

<br>

### 클래스 로더 (class loader)   
변환된 바이트 코드 파일을 JVM 내로 class를 로드(읽어들이고)하고 link 작업을 통해 메모리에 적절하게 배치 등 일련의 작업을 한다.   
+ 로딩: 클래스 읽어오는 과정   
+ 링크: 레퍼런스를 연결하는 과정   
+ 초기화: static 값들 초기화 및 변수에 할당   

JVM에는 클래스를 로드하기 위해 3가지 종류의 클래스 로더가 있다. 부트스트랩 , 확장 및 애플리케이션 클래스 로더.

<br>

### 실행 엔진 (execution engine)
클래스 로더를 통해 JVM 내부로 넘어와 runtime data area(JVM 메모리)에 배치된 바이트 코드들을 명령어 단위로 실행시킨다.
+ 인터프리터: 바이트 코드를 한줄 씩 실행. -> 성능 저하   
+ JIT 컴파일러: 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면   
                JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. -> 프로그램 실행 속도 향상   
                그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.    
+ GC(Garbage Collector): 더이상 참조되지 않는 객체를 모아서 정리한다.   
    어플리케이션이 생성한 객체의 생존 여부를 판단하여, 더이상 참조되지 않거나 null인 객체의 메모리를 해체시켜 메모리 반납을 한다.

<br>

### JVM 메모리 (Runtime DataArea)
런타임 데이터 영역은 JVM 메모리로 Java 어플리케이션이 실행하면서 할당받은 메모리영역
```
메소드나 힙은 모든 영역에 공유, 나머지 영역은 스레드에 국한되어 스레드 내에서만 공유되는 자원
```
+ 메소드 (Method Area) - 클래스 구조와 필드 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장. 모든 스레드 간 공유 자원이다.   
런타임 중에 할당된 메모리 영역이 충분하지 않으면 JVM이 OutOfMemoryError를 발생시킨다   

+ 힙 (Heap Memory) - 애플리케이션 실행 중에 생성되는 모든 객체를 저장하는데 사용. 모든 스레드 간 공유 자원이다.   
힙 데이터 영역은 VM 시작 시 생성되며 메모리 회수 요청은 GC(가비지 수집기)에 의해 자동으로 수행된다. -> Java의 가장 좋은 기능 중 하나    런타임에 할당된 메모리가 충분하지 않으면 JVM이 OutOfMemoryError를 발생시킬 수 있다.   

+ 스택 - 쓰레드 마다 런타임 스택을 만들고, 그 안에 메소드 호출을 스택 프레임이라 부르는 블럭으로 쌓는다. 
  쓰레드 종료하면 런타임 스택도 사라진다.   
  지역 변수와 중간 결과를 저장. 이러한 모든 변수는 생성된 스레드에 대해 로컬입니다. 각 스레드에는 스레드가 생성될 때 동시에 생성되는 자체 JVM 스택이 있습니다. 따라서 이러한 모든 지역 변수를 스레드 지역 변수라고 합니다.   


  > StackOverflowError – 이 오류는 프로그램 실행 중에 메모리 크기가 충분하지 않은 경우 고정 크기 JVM 스택에서 발생한다.   
  > OutOfMemoryError – 동적 크기의 스택에서 더 많은 메모리가 필요하도록 확장하려고 시도하고 할당할 수 있는 추가 메모리가 없으며 OutOfMemoryError가 발생한다.


+ PC(Program Counter) 레지스터 - 쓰레드 마다 쓰레드 내 현재 실행할 instruction의 위치를 가리키는 포인터가 생성된다.   
  현재 실행 중인 명령문의 물리적 메모리 주소를 저장합니다. Java에서 각 스레드에는 별도의 PC 레지스터가 있다.   
+ 네이티브 메소드 스택 (Native Method Stacks) - 자바는 네이티브 코드도 지원하고 사용한다.   
  많은 저수준 코드는 C 및 C++와 같은 언어로 작성되고 네이티브 메서드 스택은 네이티브 코드의 명령을 보유한다.
